<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <link rel="stylesheet" href="style.css">
</head>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<!-- Create a div where the graph will take place -->
<div id="bar_chart" hidden="true" ></div>
<script>
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 90, left: 40},
        width = 600 - margin.left - margin.right,
        height = 450 - margin.top - margin.bottom;
    
    // append the barChart object to the body of the page
    var barChart = d3.select("#bar_chart")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    // Parse the Data
    d3.csv("Data/test_data.csv", function(data) {
    
    // X axis
    var x = d3.scaleBand()
      .range([ 0, width ])
      .domain(data.map(function(d) { return d.Country; }))
      .padding(0.2);
    barChart.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x))
      .selectAll("text")
        .attr("transform", "translate(-10,0)rotate(-45)")
        .style("text-anchor", "end");
    
    // Y axis
    var y = d3.scaleLinear()
      .domain([0, 13000])
      .range([ height, 0]);
    barChart.append("g")
      .call(d3.axisLeft(y));
    
    // Bars
    barChart.selectAll("mybar")
      .data(data)
      .enter()
      .append("rect")
        .attr("x", function(d) { return x(d.Country); })
        .attr("width", x.bandwidth())
        .attr("fill", "#69b3a2")
        // no bar at the beginning thus:
        .attr("height", function(d) { return height - y(0); }) // always equal to 0
        .attr("y", function(d) { return y(0); })
    
    // Animation
    barChart.selectAll("rect")
      .transition()
      .duration(800)
      .attr("y", function(d) { return y(d.Value); })
      .attr("height", function(d) { return height - y(d.Value); })
      .delay(function(d,i){console.log(i) ; return(i*100)})
    
    })
    </script>

<div id="stacked_chart">
    <button onclick="stacked_update('Data/q18a.csv')">Job Training</button>
    <button onclick="stacked_update('Data/q18b.csv')">Health Information</button>
    <button onclick="stacked_update('Data/q18c.csv')">Information to Trust</button>
    <button onclick="stacked_update('Data/q18d.csv')">Major Disaster</button>
</div>
<script>
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 20, left: 40},
        width = 600 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    
    // append the stackedChart object to the body of the page
    var stackedChart = d3.select("#stacked_chart")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    // // Parse the Data
    // d3.csv("Data/q18a.csv", function(data) {
    //
    //     // List of subgroups = header of the csv files = soil condition here
    //     var subgroups = data.columns.slice(1)
    //
    //     // List of groups = species here = value of the first column called group -> I show them on the X axis
    //     var groups = d3.map(data, function (d) {
    //         return (d.group)
    //     }).keys()
    //
    //     // Add X axis
    //     var x = d3.scaleBand()
    //         .domain(groups)
    //         .range([0, width])
    //         .padding([0.2])
    //     stackedChart.append("g")
    //         .attr("transform", "translate(0," + height + ")")
    //         .call(d3.axisBottom(x).tickSizeOuter(0));
    //
    //     // Add Y axis
    //     var y = d3.scaleLinear()
    //         .domain([0, 120])
    //         .range([height, 0]);
    //     stackedChart.append("g")
    //         .call(d3.axisLeft(y));
    //
    //     // color palette = one color per subgroup
    //     var color = d3.scaleOrdinal()
    //         .domain(subgroups)
    //         .range(d3.schemeSet2);
    //
    //     //stack the data? --> stack per subgroup
    //     var stackedData = d3.stack()
    //         .keys(subgroups)
    //         (data)
    //
    //     // Create a tooltip
    //     // ----------------
    //     var tooltip = d3.select("#stacked_chart")
    //         .append("div")
    //         .style("opacity", 0)
    //         .attr("class", "tooltip")
    //         .style("background-color", "white")
    //         .style("border", "solid")
    //         .style("border-width", "1px")
    //         .style("border-radius", "5px")
    //         .style("padding", "10px")
    //         .style("position","absolute");
    //
    //     // ----------------
    //     // Highlight a specific subgroup when hovered
    //     // ----------------
    //
    //     // What happens when user hover a bar
    //     var mouseover = function (d) {
    //         // what subgroup are we hovering?
    //         var subgroupName = d3.select(this.parentNode).datum().key; // This was the tricky part
    //         var subgroupValue = d.data[subgroupName];
    //         tooltip
    //             .html("subgroup: " + subgroupName + "<br>" + "Value: " + subgroupValue + "%")
    //             .style("opacity", 1);
    //         // Reduce opacity of all rect to 0.2
    //         d3.selectAll(".myRect").style("opacity", 0.2)
    //         // Highlight all rects of this subgroup with opacity 0.8. It is possible to select them since they have a specific class = their name.
    //         d3.selectAll("." + subgroupName)
    //             .style("opacity", 1)
    //     }
    //
    //     var mousemove = function(d) {
    //         tooltip
    //             .style("left", (d3.mouse(this)[0]+90) + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
    //             .style("top", (d3.mouse(this)[1]) + "px")
    //     }
    //
    //     // When user do not hover anymore
    //     var mouseleave = function (d) {
    //         tooltip
    //             .style("opacity", 0)
    //         // Back to normal opacity: 0.8
    //         d3.selectAll(".myRect")
    //             .style("opacity", 0.8)
    //     }
    //
    //     // Show the bars
    //     stackedChart.append("g")
    //         .selectAll("g")
    //         // Enter in the stack data = loop key per key = group per group
    //         .data(stackedData)
    //         .enter().append("g")
    //         .attr("fill", function (d) {
    //             return color(d.key);
    //         })
    //         .attr("class", function (d) {
    //             return "myRect " + d.key
    //         }) // Add a class to each subgroup: their name
    //         .selectAll("rect")
    //         // enter a second time = loop subgroup per subgroup to add all rectangles
    //         .data(function (d) {
    //             return d;
    //         })
    //         .enter().append("rect")
    //         .attr("x", function (d) {
    //             return x(d.data.group);
    //         })
    //         .attr("y", function (d) {
    //             return y(d[1]);
    //         })
    //         .attr("height", function (d) {
    //             return y(d[0]) - y(d[1]);
    //         })
    //         .attr("width", x.bandwidth())
    //         .attr("stroke", "grey")
    //         .on("mouseover", mouseover)
    //         .on("mousemove", mousemove)
    //         .on("mouseleave", mouseleave)
    //
    // })

    // A function that create / update the plot for a given variable:
    function stacked_update(data_new) {

        let container = document.getElementById("stacked_chart");
        let elements = container.getElementsByClassName("myRect");

        while (elements[0]) {
            elements[0].parentNode.removeChild(elements[0]);
        }

        // Parse the Data
        d3.csv(data_new, function(data) {

            // List of subgroups = header of the csv files = soil condition here
            var subgroups = data.columns.slice(1)

            // List of groups = species here = value of the first column called group -> I show them on the X axis
            var groups = d3.map(data, function (d) {
                return (d.group)
            }).keys()

            // Add X axis
            var x = d3.scaleBand()
                .domain(groups)
                .range([0, width])
                .padding([0.2])
            stackedChart.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x).tickSizeOuter(0));

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, 120])
                .range([height, 0]);
            stackedChart.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            var color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(d3.schemeSet2);

            //stack the data? --> stack per subgroup
            var stackedData = d3.stack()
                .keys(subgroups)
                (data)

            // Create a tooltip
            // ----------------
            var tooltip = d3.select("#stacked_chart")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")
                .style("position","absolute");

            // ----------------
            // Highlight a specific subgroup when hovered
            // ----------------

            // What happens when user hover a bar
            var mouseover = function (d) {
                // what subgroup are we hovering?
                var subgroupName = d3.select(this.parentNode).datum().key; // This was the tricky part
                var subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "Value: " + subgroupValue + "%")
                    .style("opacity", 1);
                // Reduce opacity of all rect to 0.2
                d3.selectAll(".myRect").style("opacity", 0.2)
                // Highlight all rects of this subgroup with opacity 0.8. It is possible to select them since they have a specific class = their name.
                d3.selectAll("." + subgroupName)
                    .style("opacity", 1)
            }

            var mousemove = function(d) {
                tooltip
                    .style("left", (d3.mouse(this)[0]+90) + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
                    .style("top", (d3.mouse(this)[1]) + "px")
            }

            // When user do not hover anymore
            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                // Back to normal opacity: 0.8
                d3.selectAll(".myRect")
                    .style("opacity", 0.8)
            }

            // Show the bars
            stackedChart.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .enter().append("g")
                .attr("fill", function (d) {
                    return color(d.key);
                })
                .attr("class", function (d) {
                    return "myRect " + d.key
                }) // Add a class to each subgroup: their name
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(function (d) {
                    return d;
                })
                .enter().append("rect")
                .attr("x", function (d) {
                    return x(d.data.group);
                })
                .attr("y", function (d) {
                    return y(d[1]);
                })
                .attr("height", function (d) {
                    return y(d[0]) - y(d[1]);
                })
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)

        })
    }

    // Initialize the plot with the first dataset
    stacked_update('Data/q18a.csv')
    </script>
</div>

<div>
  <p>
    The above chart reflects what people of different household incomes believe their communities rely on libraries for. People with 
    a household income less than $30,000 were most likely to believe that their library contributes “a lot” to helping people find 
    jobs or pursue job training as 25% of people in this income bracket said this. On the other hand, people with a household income 
    more than $75,000 were the least like two say that their library contributes “a lot” to helping people find jobs or pursue training 
    with only 18% believing this. People who are already in higher income brackets are more likely to be able to have a full-time, 
    stable job as well as more resources to use for their job search such as personal computers/laptops and also a larger professional
     network. 
  </p>
  <p>
    Additionally, as displayed in the figure above shows that the three income brackets of less than $30,000, $30,000-$49,999, and 
    $50,000-$74,999 were all equally likely to think that their public library contributes “a lot” in terms of helping people when 
    they see health information with 36% saying this in each income bracket. However, only 24% of people with a household income of
     more than $75,000 believed the library contributed a lot in regards to getting health information. The people who are in 
     significantly higher income brackets are more likely to have health insurance and also be able to afford any costs associated 
     with medical visits and treatments. However people who do not have as high of a household income can not afford unexpected 
     health related costs so they are more likely to rely on public resources like the library to find information about their health 
     issues and find ways to minimize costs associated with it.
  </p>
</div>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz">    <button onclick="update(data1, '#83e47b')">Sex</button>
    <button onclick="update(data2, '#E48DAE')">Race</button>
    <button onclick="update(data3, '#e4e06a')">Age</button>
    <button onclick="update(data4, '#e47e50')">Education</button>
    <button onclick="update(data5, '#61DFE4')">Household Income</button></div>
<script>

    // create 2 data_set
    var data1 = [
        {group: "Male", value: 33},
        {group: "Female", value: 28}
    ];

    var data2 = [
        {group: "White", value: 29},
        {group: "Black", value: 38},
        {group: "Hispanic", value: 48}
    ];

    var data3 = [
        {group: "16-17", value: 19},
        {group: "18-29", value: 23},
        {group: "30-49", value: 35},
        {group: "50-64", value: 42},
        {group: "65+", value: 33}
    ];

    var data4 = [
        {group: "Less than HS", value: 31},
        {group: "Grad HS", value: 32},
        {group: "Some College", value: 34},
        {group: "College Grad", value: 34}
    ];

    var data5 = [
        {group: "< $30,000", value: 41},
        {group: "$30,000 - $49,999", value: 33},
        {group: "$50,000 - $74,999", value: 32},
        {group: "$75,000+", value: 26}
    ];


    // set the dimensions and margins of the graph
    var margin = {top: 30, right: 30, bottom: 70, left: 60},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    // Initialize the X axis
    var x = d3.scaleBand()
        .range([ 0, width ])
        .padding(0.2);
    var xAxis = svg.append("g")
        .attr("transform", "translate(0," + height + ")")

    // Initialize the Y axis
    var y = d3.scaleLinear()
        .range([ height, 0]);
    var yAxis = svg.append("g")
        .attr("class", "myYaxis")


    // A function that create / update the plot for a given variable:
    function update(data, color) {

        // Update the X axis
        x.domain(data.map(function(d) { return d.group; }))
        xAxis.call(d3.axisBottom(x))

        // Update the Y axis
        y.domain([0, d3.max(data, function(d) { return d.value }) ]);
        yAxis.transition().duration(1000).call(d3.axisLeft(y));

        // Create the u variable
        var u = svg.selectAll("rect")
            .data(data)

        u
            .enter()
            .append("rect") // Add a new rect for each new elements
            .merge(u) // get the already existing elements as well
            .transition() // and apply changes to all of them
            .duration(1200)
            .attr("x", function(d) { return x(d.group); })
            .attr("y", function(d) { return y(d.value); })
            .attr("width", x.bandwidth())
            .attr("height", function(d) { return height - y(d.value); })
            .attr("fill", color)

        // If less group in the new dataset, I delete the ones not in use anymore
        u
            .exit()
            .remove()
    }

    // Initialize the plot with the first dataset
    update(data1, "#83e47b")

</script>

<div>
  <p>As shown in the above graph, people who have a household income of less than $30,000 were the most likely to say that a library 
    closing would have a major impact on their community with 41% of respondents in this income bracket saying that. This income 
    bracket was also the one that was most likely to say that their community relies a lot on the library to find jobs or pursue job 
    training so with this particular group could potentially find their community suffering from an expanding socioeconomic gap from 
    people in high income brackets. Without access to a library, people may be unable to find as wide of a variety of jobs and could
     be missing out on better opportunities because they are no longer accessible to them without the resource of a library. This would 
    also likely have an effect on the overall health of people with lower incomes in the community because many of them reported that  
    the library is a community that is used "a lot" to seek out health-related information. If the public library were closed, this
    people would be cut off from access to resources that allow them to find adequate medical attention that they can afford. This 
    would likely result in a lack of seekiing medical attention, hurting the health of the community, or force low-income households
    to go into debt as a result of high, unexpected medical fees. </p>
</div>